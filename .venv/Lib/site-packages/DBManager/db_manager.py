import sqlite3

from datetime import datetime

from os import path,rename,remove
import pandas as pd

class CSVManager:
    def __init__(self, file_path="data\\concubines.csv"):
        self.file_path = file_path
        self.df = pd.read_csv(file_path)

    def add_row(self, row_data):
        # Satır ekleme
        new_row = pd.DataFrame([row_data], columns=self.df.columns)
        self.df = pd.concat([self.df, new_row], ignore_index=True)

    def delete_row(self, index):
        # Satır silme
        if index in self.df.index:
            self.df = self.df.drop(index)
        else:
            print("Index out of range")

    def read_column(self, column_name="name"):
        # Sütun okuma
        if column_name in self.df.columns:
            return self.df[column_name].tolist()
        else:
            print("Column not found")
            return None

    def get_index_by_value(self, value, column_name="name"):
        """
        Belirtilen sütundaki değere göre satırın indeksini bulur.
        :param column_name: Aranacak sütun adı.
        :param value: Aranacak değer.
        :return: Eşleşen ilk satırın indeksi veya -1.
        """
        if column_name in self.df.columns:
            matching_rows = self.df[self.df[column_name] == value]
            if not matching_rows.empty:
                return matching_rows.index[0]
        print("Value not found")
        return False

    def save(self):
        """
        Mevcut veri çerçevesini orijinal dosyanın üzerine kaydeder.
        """
        self.df.to_csv(self.file_path, index=False)

    def to_2d_list(self):
        """
        Veri çerçevesindeki verileri iki boyutlu liste olarak döndürür.
        :return: İki boyutlu liste.
        """
        return self.df.values.tolist()
    def get_row_by_name(self, name):
        """
        İsme göre satırı döndürür.
        :param name: Aranacak isim.
        :return: Eşleşen satır veya None.
        """
        if 'name' in self.df.columns:
            matching_row = self.df[self.df['name'] == name]
            if not matching_row.empty:
                return matching_row.iloc[0].to_dict()
        print("Name not found")
        return None
    def get_column_names(self):
        """
        Veri çerçevesinin başlıklarını döndürür.
        :return: Başlıkların listesi.
        """
        return self.df.columns.tolist()
class ProductRecords:
    def __init__(self, db_name="data\\productrecords.sql"):
        self.conn = sqlite3.connect(db_name)
        self.cursor = self.conn.cursor()
        self.db_name=db_name
        self.create_table()

    def create_table(self):
        self.cursor.execute('''CREATE TABLE IF NOT EXISTS products (
            product_name TEXT,
            barcode TEXT,
            amount REAL,
            selling_price REAL,
            piece INTEGER,
            unit TEXT,
            time TEXT,
            date TEXT,
            user TEXT,
            process_type TEXT,
            customer TEXT,
            payment_status TEXT,
            description TEXT,
            regulation TEXT
        )''')
        self.conn.commit()
    def get_by_row_id_as_dict(self, row_id):
        self.cursor.execute('SELECT * FROM products WHERE ROWID=?', (row_id,))
        result = self.cursor.fetchone()
        if result:
            return {
                "product_name": result[0],
                "barcode": result[1],
                "amount": result[2],
                "selling_price": result[3],
                "piece": result[4],
                "unit": result[5],
                "time": result[6],
                "date": result[7],
                "user": result[8],
                "process_type": result[9],
                "customer": result[10],
                "payment_status": result[11],
                "description": result[12],
                "regulation": result[13]
            }
        return None
    def refresh_for_time(self):
        # Create a temporary table to store sorted data
        self.cursor.execute('''
            CREATE TEMPORARY TABLE sorted_products AS
            SELECT * FROM products
            ORDER BY datetime(substr(date, 7, 4) || '-' || substr(date, 4, 2) || '-' || substr(date, 1, 2) || ' ' || time) DESC
        ''')

        # Clear the original table
        self.cursor.execute('DELETE FROM products')

        # Insert sorted data back into the original table
        self.cursor.execute('''
            INSERT INTO products
            SELECT * FROM sorted_products
        ''')

        # Commit the changes and drop the temporary table
        self.conn.commit()
        self.cursor.execute('DROP TABLE sorted_products')

    def add(self, product_name, barcode, amount, selling_price, piece, unit, user, process_type, customer, payment_status, description=None, regulation="original", time=None, date=None):
        now = datetime.now()
        if time is None:
            time = now.strftime("%H:%M:%S")
        if date is None:
            date = now.strftime("%d/%m/%Y")
        self.cursor.execute('''INSERT INTO products (
            product_name, barcode, amount, selling_price, piece, unit, time, date, user, process_type, customer, payment_status, description, regulation
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)''', 
        (product_name, barcode, float(amount), float(selling_price), int(piece), unit, time, date, user, process_type, customer, payment_status, description, regulation))
        self.conn.commit()

    def find_row_id(self, product_name, barcode, amount, selling_price, piece, unit, time, date, user, process_type, customer, payment_status, description, regulation="original"):
        self.cursor.execute('''SELECT ROWID FROM products WHERE
            product_name=? AND barcode=? AND amount=? AND selling_price=? AND piece=? AND unit=? AND time=? AND date=? AND user=? AND process_type=? AND customer=? AND payment_status=? AND description=? AND regulation=?''',
            (product_name, barcode, amount, selling_price, piece, unit, time, date, user, process_type, customer, payment_status, description, regulation))
        result = self.cursor.fetchone()
        return result[0] if result else None

    def get_by_row_id(self, row_id):
        self.cursor.execute('SELECT * FROM products WHERE ROWID=?', (row_id,))
        return self.cursor.fetchone()

    def get_stock(self, identifier):
        self.cursor.execute('''SELECT SUM(piece) FROM products WHERE product_name=? OR barcode=?''', (identifier, identifier))
        result = self.cursor.fetchone()
        return result[0] if result else 0

    def get_customer(self, customer):
        self.cursor.execute('''SELECT * FROM products WHERE customer=?''', (customer,))
        return self.cursor.fetchall()

    def get_product(self, product):
        self.cursor.execute('''SELECT * FROM products WHERE product_name=?''', (product,))
        return self.cursor.fetchall()

    def get_barcode(self, barcode):
        self.cursor.execute('''SELECT * FROM products WHERE barcode=?''', (barcode,))
        return self.cursor.fetchall()
    def get_user(self, user):
        self.cursor.execute('''SELECT * FROM products WHERE user=?''', (user,))
        return self.cursor.fetchall()
    def get_unit(self, unit):
        self.cursor.execute('''SELECT * FROM products WHERE unit=?''', (unit,))
        return self.cursor.fetchall()
    def get_process_type(self, process_type):
        self.cursor.execute('''SELECT * FROM products WHERE process_type=?''', (process_type,))
        return self.cursor.fetchall()
    def get_payment_status(self, payment_status):
        self.cursor.execute('''SELECT * FROM products WHERE payment_status=?''', (payment_status,))
        return self.cursor.fetchall()

    def get_first_data(self, identifier):
        self.cursor.execute('''SELECT * FROM products WHERE product_name=? OR barcode=? ORDER BY ROWID ASC LIMIT 1''', (identifier, identifier))
        result = self.cursor.fetchone()
        if result:
            return {
                "product_name": result[0],
                "barcode": result[1],
                "amount": result[2],
                "selling_price": result[3],
                "piece": result[4],
                "unit": result[5],
                "time": result[6],
                "date": result[7],
                "user": result[8],
                "process_type": result[9],
                "customer": result[10],
                "payment_status": result[11],
                "description": result[12],
                "regulation": result[13]
            }
        return None
    def get_first_data_with_process_type(self, identifier, process_type):
        self.cursor.execute('''
            SELECT * FROM products 
            WHERE (product_name=? OR barcode=?) AND process_type=?
            ORDER BY ROWID ASC 
            LIMIT 1
        ''', (identifier, identifier, process_type))
        result = self.cursor.fetchone()
        if result:
            return {
                "product_name": result[0],
                "barcode": result[1],
                "amount": result[2],
                "selling_price": result[3],
                "piece": result[4],
                "unit": result[5],
                "time": result[6],
                "date": result[7],
                "user": result[8],
                "process_type": result[9],
                "customer": result[10],
                "payment_status": result[11],
                "description": result[12],
                "regulation": result[13]
            }
        return None
    def find_row_id_by_name_date_time(self, product_name, date, time):
        self.cursor.execute('''
            SELECT ROWID FROM products 
            WHERE product_name=? AND date=? AND time=?
        ''', (product_name, date, time))
        result = self.cursor.fetchone()
        return result[0] if result else None
    def get_last_data_with_process_type(self, identifier, process_type):
        self.cursor.execute('''
            SELECT * FROM products 
            WHERE (product_name=? OR barcode=?) AND process_type=?
            ORDER BY ROWID DESC 
            LIMIT 1
        ''', (identifier, identifier, process_type))
        result = self.cursor.fetchone()
        if result:
            return {
                "product_name": result[0],
                "barcode": result[1],
                "amount": result[2],
                "selling_price": result[3],
                "piece": result[4],
                "unit": result[5],
                "time": result[6],
                "date": result[7],
                "user": result[8],
                "process_type": result[9],
                "customer": result[10],
                "payment_status": result[11],
                "description": result[12],
                "regulation": result[13]
            }
        return None
    def get_last_data(self, identifier):
        self.cursor.execute('''SELECT * FROM products WHERE product_name=? OR barcode=? ORDER BY ROWID DESC LIMIT 1''', (identifier, identifier))
        result = self.cursor.fetchone()
        if result:
            return {
                "product_name": result[0],
                "barcode": result[1],
                "amount": result[2],
                "selling_price": result[3],
                "piece": result[4],
                "unit": result[5],
                "time": result[6],
                "date": result[7],
                "user": result[8],
                "process_type": result[9],
                "customer": result[10],
                "payment_status": result[11],
                "description": result[12],
                "regulation": result[13]
            }
        return None

    def get_table(self):
        self.cursor.execute('SELECT * FROM products')
        return self.cursor.fetchall()

    def delete_row(self, row_id):
        self.cursor.execute('DELETE FROM products WHERE ROWID=?', (row_id,))
        self.conn.commit()

    def find(self, column, value):
        query = f'SELECT * FROM products WHERE {column}=?'
        self.cursor.execute(query, (value,))
        return self.cursor.fetchall()

    def get_unique_product_names(self):
        self.cursor.execute('SELECT DISTINCT product_name FROM products')
        return [row[0] for row in self.cursor.fetchall()]

    def get_unique_product_units(self):
        self.cursor.execute('SELECT DISTINCT unit FROM products')
        return [row[0] for row in self.cursor.fetchall()]

    def get_unique_payment_status(self):
        self.cursor.execute('SELECT DISTINCT payment_status FROM products')
        return [row[0] for row in self.cursor.fetchall()]

    def get_unique_customers(self):
        self.cursor.execute('SELECT DISTINCT customer FROM products')
        return [row[0] for row in self.cursor.fetchall()]

    def get_numerate_table(self):
        list_ = self.get_table()
        return [(i + 1,) + list_[i] for i in range(len(list_))]

    def get_numerate(self, list_):
        return [(i + 1,) + list_[i] for i in range(len(list_))]

    def filter_by_date(self, start_date, end_date):
        start_date_str = f"{start_date['Day']:02d}/{start_date['Month']:02d}/{start_date['Year']}"
        end_date_str = f"{end_date['Day']:02d}/{end_date['Month']:02d}/{end_date['Year']}"
        self.cursor.execute('''
            SELECT * FROM products WHERE date BETWEEN ? AND ?
        ''', (start_date_str, end_date_str))
        return self.cursor.fetchall()

    def get_unique_customers_by_process_type(self, process_type):
        self.cursor.execute('''
            SELECT DISTINCT customer
            FROM products
            WHERE process_type = ?
        ''', (process_type,))
        customers = self.cursor.fetchall()
        return [customer[0] for customer in customers] if customers else [""]

    def get_by_date(self, date_dict):
        day = int(date_dict.get('Day'))
        month = int(date_dict.get('Month'))
        year = int(date_dict.get('Year'))
        date_str = f"{day:02d}/{month:02d}/{year}"
        self.cursor.execute('''SELECT * FROM products WHERE date=?''', (date_str,))
        return self.cursor.fetchall()

class PasswordManager:
    def __init__(self):
        self.file_name = "data\\AccessData.sql"
        self.connect()
        self.create_table()
        if self.find_data("main") is None:
            self.insert_data("main","main")
            print(self.find_data("main"))

    def connect(self):
        self.connection = sqlite3.connect(self.file_name)
        self.cursor = self.connection.cursor()

    def create_table(self):
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS Data(
                name TEXT PRIMARY KEY,
                password TEXT
            )
        ''')
        self.connection.commit()

    def list_name(self):
        self.cursor.execute("SELECT name FROM Data")
        return self.cursor.fetchall()

    def insert_data(self, name, password):
        self.cursor.execute('''
            INSERT INTO Data (name, password)
            VALUES (?, ?)
        ''', (name, password))
        self.connection.commit()
        print(f"Inserted data with name: {name}")

    def delete_data(self, name):
        self.cursor.execute('''
            DELETE FROM Data WHERE name=?
        ''', (name,))
        self.connection.commit()

    def find_data(self, name):
        try:
            self.cursor.execute('''
                SELECT * FROM Data WHERE name=?
            ''', (name,))
            return self.cursor.fetchone()
        except:
            return None

    def close_connection(self):
        self.connection.close()



# Usage example
if __name__ == "__main__":
    db = ProductRecords()

    # Adding 25 complex records
    records = ["ProductA", "0000000001", 100.0, 0, 10, "unitA", "user1", "buy", "customer1", "paid"]
    db.add(*records)