# -*- coding: utf-8 -*-
"""
tkcalendar - Calendar and DateEntry widgets for Tkinter
Copyright 2017-2019 Juliette Monsel <j_4321@protonmail.com>
with contributions from:
  - Neal Probert (https://github.com/nprobert)
  - arahorn28 (https://github.com/arahorn28)

tkcalendar is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

tkcalendar is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.


DateEntry widget
"""
from tkcalendar.calendar_ import Calendar
import tkinter as tk
import customtkinter as ctk
from tkcalendar import DateEntry as tkDateEntry  # Assuming you use tkcalendar for the calendar widget

class DateEntry(ctk.CTkEntry):
    """Date selection entry with drop-down calendar."""

    def __init__(self, master=None, **kw):
        """
        Create an entry with a drop-down calendar to select a date.
        """
        # Remove unsupported arguments
        entry_kw = {key: kw.pop(key, None) for key in ['width']}
        entry_kw = {k: v for k, v in entry_kw.items() if v is not None}

        # Initialize CTkEntry
        super().__init__(master, **entry_kw)

        # Initialize drop-down calendar
        self._top_cal = tk.Toplevel(self)
        self._top_cal.withdraw()
        self._top_cal.overrideredirect(True)
        self._calendar = tkDateEntry(self._top_cal, **kw)
        self._calendar.pack()

        # Locale date parsing / formatting
        self.format_date = self._calendar.format_date
        self.parse_date = self._calendar.parse_date

        # Style
        self._theme_name = ''   # to detect theme changes
        self._setup_style()
        self.configure(style=kw.get('style', 'DateEntry'))

        # Initially selected date
        self._date = self._calendar.get_date()
        if self._date is None:
            today = self._calendar.date.today()
            self._date = today
        self._set_text(self.format_date(self._date))

        # Bindings
        self.bind('<Configure>', self._determine_downarrow_name)
        self.bind('<Map>', self._determine_downarrow_name)
        self.bind('<Leave>', lambda e: self.state(['!active']))
        self.bind('<Motion>', self._on_motion)
        self.bind('<ButtonPress-1>', self._on_b1_press)
        self._calendar.bind('<<CalendarSelected>>', self._select)
        self._calendar.bind('<FocusOut>', self._on_focus_out_cal)

    def _setup_style(self):
        """Configure style to make the DateEntry look like a Combobox."""
        self.update_idletasks()
        conf = self.cget('style')
        if conf:
            self.configure(style=conf)
        self._theme_name = 'light'  # Example theme setting

    def _determine_downarrow_name(self, event=None):
        """Determine downarrow button name."""
        try:
            self.update_idletasks()
            y = self.winfo_height() // 2
            x = self.winfo_width() - 10
            name = self.identify(x, y)
            if name:
                self._downarrow_name = name
        except ValueError:
            pass

    def _on_motion(self, event):
        """Set widget state depending on mouse position to mimic Combobox behavior."""
        x, y = event.x, event.y
        if 'disabled' not in self.state():
            if self.identify(x, y) == self._downarrow_name:
                self.state(['active'])
            else:
                self.state(['!active'])

    def _on_b1_press(self, event):
        """Trigger self.drop_down on downarrow button press and set widget state to ['pressed', 'active']."""
        x, y = event.x, event.y
        if (('disabled' not in self.state()) and self.identify(x, y) == self._downarrow_name):
            self.state(['pressed'])
            self.drop_down()

    def _on_focus_out_cal(self, event):
        """Withdraw drop-down calendar when it loses focus."""
        if self.focus_get() is not None:
            if self.focus_get() == self:
                x, y = event.x, event.y
                if (type(x) != int or type(y) != int or self.identify(x, y) != self._downarrow_name):
                    self._top_cal.withdraw()
                    self.state(['!pressed'])
            else:
                self._top_cal.withdraw()
                self.state(['!pressed'])
        else:
            if 'active' in self.state():
                self._calendar.focus_force()
            else:
                self._top_cal.withdraw()
                self.state(['!pressed'])

    def _select(self, event=None):
        """Display the selected date in the entry and hide the calendar."""
        date = self._calendar.get_date()
        if date is not None:
            self._set_text(self.format_date(date))
            self._date = date
            self.event_generate('<<DateEntrySelected>>')
        self._top_cal.withdraw()
        if 'readonly' not in self.state():
            self.focus_set()

    def _set_text(self, txt):
        """Insert text in the entry."""
        if 'readonly' in self.state():
            readonly = True
            self.state(('!readonly',))
        else:
            readonly = False
        self.delete(0, 'end')
        self.insert(0, txt)
        if readonly:
            self.state(('readonly',))

    def destroy(self):
        try:
            self.after_cancel(self._determine_downarrow_name_after_id)
        except ValueError:
            pass
        super().destroy()

    def drop_down(self):
        """Display or withdraw the drop-down calendar depending on its current state."""
        if self._calendar.winfo_ismapped():
            self._top_cal.withdraw()
        else:
            self._validate_date()
            date = self.parse_date(self.get())
            x = self.winfo_rootx()
            y = self.winfo_rooty() + self.winfo_height()
            self._top_cal.geometry(f'+{x}+{y}')
            self._top_cal.deiconify()
            self._calendar.focus_set()
            self._calendar.set_date(date)

    def state(self, *args):
        """Modify or inquire widget state."""
        if args:
            states = args[0]
            if 'disabled' in states or 'readonly' in states:
                self.configure(cursor='arrow')
            elif '!disabled' in states or '!readonly' in states:
                self.configure(cursor='xterm')
        return super().state(*args)

    def keys(self):
        """Return a list of all resource names of this widget."""
        keys = ['width']
        keys.extend(self._calendar.keys())
        return list(set(keys))

    def cget(self, key):
        """Return the resource value for a KEY given as string."""
        if key in ['width']:
            return super().cget(key)
        return self._calendar.cget(key)

    def configure(self, cnf={}, **kw):
        """
        Configure resources of a widget.

        The values for resources are specified as keyword
        arguments. To get an overview about
        the allowed keyword arguments call the method :meth:`~DateEntry.keys`.
        """
        if not isinstance(cnf, dict):
            raise TypeError("Expected a dictionary or keyword arguments.")
        kwargs = cnf.copy()
        kwargs.update(kw)

        entry_kw = {}
        keys = list(kwargs.keys())
        for key in keys:
            if key in ['width']:
                entry_kw[key] = kwargs.pop(key)
        super().configure(**entry_kw)

        kwargs['cursor'] = kwargs.pop('calendar_cursor', None)
        self._calendar.configure(kwargs)
        if 'date_pattern' in kwargs or 'locale' in kwargs:
            self._set_text(self.format_date(self._date))

    def set_date(self, date):
        """
        Set the value of the DateEntry to date.

        date can be a datetime.date, a datetime.datetime or a string
        in locale '%x' format.
        """
        try:
            txt = self.format_date(date)
        except AssertionError:
            txt = str(date)
            try:
                self.parse_date(txt)
            except Exception:
                raise ValueError(f"{date} is not a valid date.")
        self._set_text(txt)
        self._validate_date()

    def get_date(self):
        """Return the content of the DateEntry as a datetime.date instance."""
        self._validate_date()
        return self.parse_date(self.get())
